<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Mbed Target Viewer</title>
    <script src="https://code.jquery.com/jquery-3.2.1.min.js"></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.css">
    <script src="https://cdn.jsdelivr.net/npm/semantic-ui@2.4.2/dist/semantic.min.js"></script>
    <script src="https://semantic-ui.com/javascript/library/tablesort.js"></script>

    <style>
        body {
            margin-left: 30px;
            margin-right: 30px;
            margin-top: 30px;
        }
        select {
            height: 300px;
            padding-right: 10px;
        }
        div#filter-container {
            overflow: auto;
            padding-bottom: 20px;
        }
        div#filter-container>div {
            float: left;
            padding-left: 20px;
        }
    </style>

</head>

<body>
    <h1> Mbed OS Target Viewer</h1>

    <div id="filter-container">

        <div>
            <label for="features">Filter by Features: <br /> </label>
            <select id="features" multiple>
            </select>
        </div>

        <div>
            <label for="manufacturers">Filter by Manufaturer: <br /> </label>
            <select id="manufacturers" multiple>
            </select>
        </div>
    </div>

    <input type="submit" onclick="compileFilters(), renderTable()" value="Filter">
    <input type="submit" onclick="clearFilters(), renderTable()" value="Clear Filters">

    <p id="activefilters"> </p>

    <h3> Matched <span id="targetnum">0</span> targets</h3>
    <table id="datatable" class="ui sortable celled table"></table>

    <script>

        // cols of the table
        table_cols = ["Target Name", "Manufacturer", "CPU Name", "Supported Features", "Board Components", "RAM Size (kiB)", "ROM Size (kiB)"]

        var targetList = [];

        // Maps JSON name of feature to a human readable form
        var humanReadableFeatureNames = {
            "802_15_4_PHY": "802.15.4 Radio", // TODO: is this accurate?
            "ANALOGIN": "Analog Inputs",
            "ANALOGOUT": "Analog Outputs",
            "CAN": "CAN",
            "DEBUG_AWARENESS": "Semihost Detectable",
            "EMAC": "Ethernet MAC",
            "ETHERNET": "Ethernet PHY", // TODO: ignore this one since it is not accurate
            "FLASH": "Onboard Flash",
            "LOCALFILESYSTEM": "MBED Disk Access from App",
            "LPTICKER": "Low-Power Ticker",
            "I2C": "I²C",
            "I2CSLAVE": "I²C Slave",
            "I2C_ASYNCH": "Asynchronous I²C",
            "INTERRUPTIN": "Interrupt Inputs",
            "USTICKER": "Microsecond Ticker",
            "PORTIN": "Full-Port Input",
            "PORTINOUT": "Full-Port I/O",
            "PORTOUT": "Full-Port Output",
            "PWMOUT": "PWM Out",
            "RESET_REASON": "Reset Reason",
            "RTC": "Real-Time Clock",
            "SEMIHOST": "Semihost", // TODO: ignore this one since it is not accurate
            "SERIAL": "Serial",
            "SERIAL_FC": "Serial Flow Control",
            "SLEEP": "Sleep",
            "SPI": "SPI",
            "SPISLAVE": "SPI Slave",
            "SPI_ASYNCH": "Asynchronous SPI",
            "STDIO_MESSAGES": "Stdout",
            "USBDEVICE": "USB Device",
            "WATCHDOG": "Watchdog Timer",
        }

        // Map of manufacturer names in extra_labels to display name
        var knownManufacturers = {
            "Silicon_Labs": "Silicon Labs",
            "NXP": "NXP",
            "Freescale": "NXP/Freescale",
            "Analog_Devices": "Analog Devices",
            "STM": "STMicroelectronics",
            "RENESAS": "Renesas",
            "Maxim": "Maxim",
            "NORDIC": "Nordic Semiconductor",
            "NUVOTON": "Nuvoton",
            "TOSHIBA": "Toshiba",
            "Cypress": "Cypress",
            "Samsung": "Samsung",
            "Atmel": "Microchip/Atmel", // note: Mbed 6 doesn't currently support any Atmel MCUs, but some older versions do.
            "GigaDevice": "GigaDevice",
        }

        var filtFeatures = [];
        var filtManufacturers = [];
        for (manu in knownManufacturers) filtManufacturers.push(knownManufacturers[manu]); 
        var newFeatures;
        var newManufacturers;

        function displayVals() {
            newFeatures = $("#features").val() || [];
            newManufacturers = $("#manufacturers").val() || [];
            // When using jQuery 3:
            // var multipleValues = $( "#multiple" ).val();
        }

        $("select").change(displayVals);

        function compileFilters() {
            // compile list of filtered features and manufacturers
            filtFeatures = [].concat(filtFeatures, newFeatures);
            if (newManufacturers.length) filtManufacturers = filtManufacturers.filter(value => newManufacturers.includes(value));

            $("p#activefilters").html(" <b>Features Filtered:</b> " + filtFeatures.join(", ") + "<br>" +
                " <b>Manufacturers Filtered:</b> " + filtManufacturers.join(", "));
        }

        function clearFilters() {
            // reset all filters
            filtFeatures = [];
            filtManufacturers = [];
            for (manu in knownManufacturers) filtManufacturers.push(knownManufacturers[manu]); 
            $("p#activefilters").html("");
        }

        // Hexadecimal to Decimal Converter
        function hexToDec(hex) {
            var result = 0, digitValue;
            hex = hex.toLowerCase();
            for (var i = 2; i < hex.length; i++) {
                digitValue = '0123456789abcdefgh'.indexOf(hex[i]);
                result = result * 16 + digitValue;
            }
            return result;
        }

        // Copy a single aggregate property over to the definition.
        // These properties can be defined at multiple levels and must be merged together.
        function copyAggregateProperty(definition, definitionPropName, targetJson, targetName, propertyName) {
            // Property name by itself replaces the current value
            if (propertyName in targetJson[targetName]) {
                definition[definitionPropName] = targetJson[targetName][propertyName];
            }
            // _add adds to the current value
            if (propertyName + "_add" in targetJson[targetName]) {
                definition[definitionPropName] = definition[definitionPropName].concat(targetJson[targetName][propertyName + "_add"]);
            }
            // _remove subtracts from the current value
            if (propertyName + "_remove" in targetJson[targetName]) {
                // from here: https://stackoverflow.com/questions/45342155/how-to-subtract-one-array-from-another-element-wise-in-javascript
                definition[definitionPropName] = definition[definitionPropName].filter(
                    item => !targetJson[targetName][propertyName + "_remove"].includes(item));
            }
        }

        // Copy the relevant data from the JSON definition into the given
        // object.
        function copyTargetProperties(definition, targetJson, targetName) {
            // First handle superclasses of this target.
            // Follows Mbed OS "high to low, left to right" parser order
            if ("inherits" in targetJson[targetName]) {
                for (superclassIdx in targetJson[targetName]["inherits"]) {
                    copyTargetProperties(definition, targetJson, targetJson[targetName]["inherits"][superclassIdx]);
                }
            }

            if ("device_name" in targetJson[targetName]) {
                definition["CPU Name"] = targetJson[targetName]["device_name"];
            }
            if ("mbed_ram_size" in targetJson[targetName]) {
                definition["RAM Size (kiB)"] = parseInt(hexToDec(targetJson[targetName]["mbed_ram_size"]) / 1000);
            }
            if ("mbed_rom_size" in targetJson[targetName]) {
                definition["ROM Size (kiB)"] = parseInt(hexToDec(targetJson[targetName]["mbed_rom_size"]) / 1000);
            }

            copyAggregateProperty(definition, "Supported Features", targetJson, targetName, "device_has");
            copyAggregateProperty(definition, "Board Components", targetJson, targetName, "components");
            copyAggregateProperty(definition, "Extra Labels", targetJson, targetName, "extra_labels");

        }

        // Build the list of targets using the raw JSON file.
        // Resolves inheritance declarations and flattens the tree
        // into a list.
        function buildTargetList(targetJson) {
            for (targetName in targetJson) {
                // If the target does not have the "device_name" or "supported_form_factors"
                // properties then it is a super-type, not an actual target board
                if (!("device_name" in targetJson[targetName] || "supported_form_factors" in targetJson[targetName])) {
                    continue;
                }

                if (targetName == "Target") {
                    // Skip default target
                    continue;
                }

                var targetDefinition = { "Target Name": targetName }

                copyTargetProperties(targetDefinition, targetJson, targetName);

                var filtFeatures = displayVals();

                // convert JSON feature names to human readable
                for (featureIdx in targetDefinition["Supported Features"]) {
                    if (targetDefinition["Supported Features"][featureIdx] in humanReadableFeatureNames) {
                        targetDefinition["Supported Features"][featureIdx] = humanReadableFeatureNames[targetDefinition["Supported Features"][featureIdx]];
                    }
                }

                // Try to figure out the manufacturer from the Extra Features
                var foundManufacturer = false;
                for (labelIdx in targetDefinition["Extra Labels"]) {
                    if (targetDefinition["Extra Labels"][labelIdx] in knownManufacturers) {
                        targetDefinition["Manufacturer"] = knownManufacturers[targetDefinition["Extra Labels"][labelIdx]];
                        foundManufacturer = true;
                        break;
                    }
                }
                if (!foundManufacturer) {
                    targetDefinition["Manufacturer"] = "";
                }

                targetList.push(targetDefinition);
            }
        }

        // Redraw the table, taking the current filters into account
        function renderTable() {

            table = "<thead>"

            // draw header row
            table += "<tr>";
            for (columnIdx in table_cols) {
                table += "<th>";
                table += table_cols[columnIdx];
                table += "</th>";
            }
            table += "</tr>";

            table += "</thead>";
            table += "<tbody>";

            var matchedTargets = 0;

            var selectFeature = document.getElementById("features");
            var optionsFeature = [];

            var selectManu = document.getElementById("manufacturers");
            var optionsManu = [];

            // draw element rows
            for (targetIdx in targetList) {
                // filter out targets that do not have the required features
                var missingQuals = false;
                for (feature in filtFeatures) {
                    if (!targetList[targetIdx]["Supported Features"].includes(filtFeatures[feature])) {
                        missingQuals = true;
                        break;
                    }
                }
                if (!filtManufacturers.includes(targetList[targetIdx]["Manufacturer"]) && filtManufacturers.length) {
                    missingQuals = true;
                }
                if (missingQuals) {
                    continue;
                }

                // remake feature selection form based on the supported features within the selection
                for (feature in targetList[targetIdx]["Supported Features"]) {
                    var option = document.createElement('option');
                    option.text = option.value = targetList[targetIdx]["Supported Features"][feature];
                    if (!optionsFeature.includes(option.outerHTML)
                        && !filtFeatures.includes(targetList[targetIdx]["Supported Features"][feature])) {
                        optionsFeature.push(option.outerHTML);
                    }
                }

                // remake manufacturer selection form based on the supported features within the selection
                var option = document.createElement('option');
                option.text = option.value = targetList[targetIdx]["Manufacturer"];
                if (!optionsManu.includes(option.outerHTML)) {
                    optionsManu.push(option.outerHTML);
                }


                matchedTargets++;
                table += "<tr>";
                for (columnIdx in table_cols) {
                    if (columnIdx == 1) {
                        // by default, sort by the manufacturer in ascending order
                        table += "<td class=\"sorted ascending\">";
                    }
                    else {
                        table += "<td>";
                    }

                    var currCol = table_cols[columnIdx];

                    if (!(currCol in targetList[targetIdx])) {
                        // render undefined values as empty string
                    }
                    else if (columnIdx == 0) {
                        if (columnIdx == 0 && (targetList[targetIdx][table_cols[columnIdx]]).substr(0, 6) == "NUCLEO") {
                            var link = "https://os.mbed.com/platforms/ST-Nucleo-" + (targetList[targetIdx][currCol]).substr(7, 6) + "/";
                            table += "<a href=" + link + ">" + targetList[targetIdx][table_cols[columnIdx]] + "</a>";
                        }
                        else {
                            table += targetList[targetIdx][currCol];
                        }
                    }
                    else if (Array.isArray(targetList[targetIdx][currCol])) {
                        // render arrays as bullet lists
                        table += "<ul>";
                        targetList[targetIdx][currCol].forEach(value => table += "<li>" + value + "</li>");
                        table += "</ul>";
                    }
                    else {
                        table += targetList[targetIdx][currCol];
                    }

                    table += "</td>";
                }
                table += "</tr>";
            }

            table += "</tbody>";

            // replace current contents
            document.getElementById("datatable").innerHTML = table;
            $("#targetnum").html(matchedTargets)

            // resort
            $("#datatable").tablesort()
            $("#datatable>thead>tr>th:nth-child(2)").trigger("click");

            // clear and remake feature selection form
            var i, L = selectFeature.options.length - 1;
            for (i = L; i >= 0; i--) selectFeature.remove(i);
            selectFeature.insertAdjacentHTML('beforeEnd', optionsFeature.join('\n'));

            // clear and remake manufacturer selection form
            var i, L = selectManu.options.length - 1;
            for (i = L; i >= 0; i--) selectManu.remove(i);
            selectManu.insertAdjacentHTML('beforeEnd', optionsManu.join('\n'));
        }

        $.getJSON('https://raw.githubusercontent.com/ARMmbed/mbed-os/master/targets/targets.json', function (data) {
            buildTargetList(data);
            renderTable();
        });
    </script>

</body>
</html>